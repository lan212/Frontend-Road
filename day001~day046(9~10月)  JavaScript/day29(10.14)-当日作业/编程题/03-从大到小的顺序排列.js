// 3.按照从大到小的顺序排列 ，var arr= [10, 5, 34, 59, 98],最后打印排序后的数组。

// 分析：

// 方法一：使用冒泡排序，从大到小
// 步骤：
var arr = [10, 5, 34, 59, 98]
// 先动用一个循环，循环的变量i作为，比较的轮数，共需要比较4轮]
// 既然这个循环是控制轮数的，不作为索引，为什么我们不从1到4，还是一定要从0开始循环到3（length-1）呢？因为这个变量i会在内部循环中影响j索引的取值范围，只有从0开始，才能使内部循环每次比较时，都比较到最后一位，否者如果是1到arr.length的话，最后一位元素会失去对比机会
for (var i=0; i<arr.length-1; i++)
{
    // 再动用一个循环，循环变量j代表数组依次比较时的索引，j的取值范围代表外层每轮循环的比较次数,随着外层每轮循环的递增，而减少比较次数
    for (var j=0; j<arr.length-1-i; j++)
    {
        // 根据循环，依次判断相邻两个元素的大小,如果相邻的下个元素比本元素大，那么通过判断条件，进入代码块，替换两个元素的位置
        if (arr[j]<arr[j+1])
        {
            // 声明一个临时变量，存储需要换位置的arr[j]的值
            var temp = arr[j]
            // 既然相邻的下一位数比上一位数大，但是我们想要的是从大到小，所以将两个元素的位置互换
            arr[j] = arr[j+1]
            // 将临时变量里保存好的arr[j]元素，放到下一个位置
            arr[j+1] = temp
        }
    }
}
// 输出排序后的数组
console.log(arr);


// 方法二：使用sort()
var arr = [10, 5, 34, 59, 98]
// 使用sort（）从大到小
arr.sort(function(a,b){
    return b-a
})
// 输出
console.log(arr);

